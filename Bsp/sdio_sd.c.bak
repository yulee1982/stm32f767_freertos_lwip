/**
  ******************************************************************************
  * @file    stm32f4_discovery_sdio_sd.c
  * @author  MCD Application Team
  * @version V1.0.2
  * @date    05-March-2012
  * @brief   This file provides a set of functions needed to manage the SDIO SD
  *          Card memory mounted on STM32F4 Discovery board.
  *
  *
  *  @verbatim
  *
  *          ===================================================================
  *                                   How to use this driver
  *          ===================================================================
  *          It implements a high level communication layer for read and write
  *          from/to this memory. The needed STM32 hardware resources (SDIO and
  *          GPIO) are defined in stm32f4_discovery.h file, and the initialization is
  *          performed in SD_LowLevel_Init() function declared in stm32f4_discovery.c
  *          file.
  *          You can easily tailor this driver to any other development board,
  *          by just adapting the defines for hardware resources and
  *          SD_LowLevel_Init() function.
  *
  *          A - SD Card Initialization and configuration
  *          ============================================
  *            - To initialize the SD Card, use the SD_Init() function.  It
  *              Initializes the SD Card and put it into StandBy State (Ready
  *              for data transfer). This function provide the following operations:
  *
  *              1 - Apply the SD Card initialization process at 400KHz and check
  *                  the SD Card type (Standard Capacity or High Capacity). You
  *                  can change or adapt this frequency by adjusting the
  *                  "SDIO_INIT_CLK_DIV" define inside the stm32f4_discovery.h file.
  *                  The SD Card frequency (SDIO_CK) is computed as follows:
  *
  *                     +---------------------------------------------+
  *                     | SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) |
  *                     +---------------------------------------------+
  *
  *                  In initialization mode and according to the SD Card standard,
  *                  make sure that the SDIO_CK frequency don't exceed 400KHz.
  *
  *              2 - Get the SD CID and CSD data. All these information are
  *                  managed by the SDCardInfo structure. This structure provide
  *                  also ready computed SD Card capacity and Block size.
  *
  *              3 - Configure the SD Card Data transfer frequency. By Default,
  *                  the card transfer frequency is set to 24MHz. You can change
  *                  or adapt this frequency by adjusting the "SDIO_TRANSFER_CLK_DIV"
  *                  define inside the stm32f4_discovery.h file.
  *                  The SD Card frequency (SDIO_CK) is computed as follows:
  *
  *                     +---------------------------------------------+
  *                     | SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) |
  *                     +---------------------------------------------+
  *
  *                  In transfer mode and according to the SD Card standard,
  *                  make sure that the SDIO_CK frequency don't exceed 25MHz
  *                  and 50MHz in High-speed mode switch.
  *                  To be able to use a frequency higher than 24MHz, you should
  *                  use the SDIO peripheral in bypass mode. Refer to the
  *                  corresponding reference manual for more details.
  *
  *              4 -  Select the corresponding SD Card according to the address
  *                   read with the step 2.
  *
  *              5 -  Configure the SD Card in wide bus mode: 4-bits data.
  *
  *          B - SD Card Read operation
  *          ==========================
  *           - You can read SD card by using two function: SD_ReadBlock() and
  *             SD_ReadMultiBlocks() functions. These functions support only
  *             512-byte block length.
  *           - The SD_ReadBlock() function read only one block (512-byte). This
  *             function can transfer the data using DMA controller or using
  *             polling mode. To select between DMA or polling mode refer to
  *             "SD_DMA_MODE" or "SD_POLLING_MODE" inside the stm32f4_discovery_sdio_sd.h
  *             file and uncomment the corresponding line. By default the SD DMA
  *             mode is selected
  *           - The SD_ReadMultiBlocks() function read only mutli blocks (multiple
  *             of 512-byte).
  *           - Any read operation should be followed by two functions to check
  *             if the DMA Controller and SD Card status.
  *              - SD_ReadWaitOperation(): this function insure that the DMA
  *                controller has finished all data transfer.
  *              - SD_GetStatus(): to check that the SD Card has finished the
  *                data transfer and it is ready for data.
  *
  *           - The DMA transfer is finished by the SDIO Data End interrupt.
  *             User has to call the SD_ProcessIRQ() function inside the SDIO_IRQHandler()
  *             and SD_ProcessDMAIRQ() function inside the DMA2_Streamx_IRQHandler().
  *             Don't forget to enable the SDIO_IRQn and DMA2_Stream3_IRQn or
  *             DMA2_Stream6_IRQn interrupts using the NVIC controller.
  *
  *          C - SD Card Write operation
  *          ===========================
  *           - You can write SD card by using two function: SD_WriteBlock() and
  *             SD_WriteMultiBlocks() functions. These functions support only
  *             512-byte block length.
  *           - The SD_WriteBlock() function write only one block (512-byte). This
  *             function can transfer the data using DMA controller or using
  *             polling mode. To select between DMA or polling mode refer to
  *             "SD_DMA_MODE" or "SD_POLLING_MODE" inside the stm32f4_discovery_sdio_sd.h
  *             file and uncomment the corresponding line. By default the SD DMA
  *             mode is selected
  *           - The SD_WriteMultiBlocks() function write only mutli blocks (multiple
  *             of 512-byte).
  *           - Any write operation should be followed by two functions to check
  *             if the DMA Controller and SD Card status.
  *              - SD_ReadWaitOperation(): this function insure that the DMA
  *                controller has finished all data transfer.
  *              - SD_GetStatus(): to check that the SD Card has finished the
  *                data transfer and it is ready for data.
  *
  *           - The DMA transfer is finished by the SDIO Data End interrupt.
  *             User has to call the SD_ProcessIRQ() function inside the SDIO_IRQHandler()
  *             and SD_ProcessDMAIRQ() function inside the DMA2_Streamx_IRQHandler().
  *             Don't forget to enable the SDIO_IRQn and DMA2_Stream3_IRQn or
  *             DMA2_Stream6_IRQn interrupts using the NVIC controller.
  *
  *
  *          D - SD card status
  *          ==================
  *           - At any time, you can check the SD Card status and get the SD card
  *             state by using the SD_GetStatus() function. This function checks
  *             first if the SD card is still connected and then get the internal
  *             SD Card transfer state.
  *           - You can also get the SD card SD Status register by using the
  *             SD_SendSDStatus() function.
  *
  *          E - Programming Model (Selecting DMA for SDIO data Transfer)
  *          ============================================================
  *             Status = SD_Init(); // Initialization Step as described in section A
  *
  *             // SDIO Interrupt ENABLE
  *             NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
  *             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
  *             NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  *             NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  *             NVIC_Init(&NVIC_InitStructure);
  *             // DMA2 ST
  *             NVIC_InitStructure.NVIC_IRQChannel = SD_SDIO_DMA_IRQn;
  *             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  *             NVIC_Init(&NVIC_InitStructure);
  *
  *             // Write operation as described in Section C
  *             Status = SD_WriteBlock(buffer, address, 512);
  *             Status = SD_WaitWriteOperation();
  *             while(SD_GetStatus() != SD_TRANSFER_OK);
  *
  *             Status = SD_WriteMultiBlocks(buffer, address, 512, NUMBEROFBLOCKS);
  *             Status = SD_WaitWriteOperation();
  *             while(SD_GetStatus() != SD_TRANSFER_OK);
  *
  *             // Read operation as described in Section B
  *             Status = SD_ReadBlock(buffer, address, 512);
  *             Status = SD_WaitReadOperation();
  *             while(SD_GetStatus() != SD_TRANSFER_OK);
  *
  *             Status = SD_ReadMultiBlocks(buffer, address, 512, NUMBEROFBLOCKS);
  *             Status = SD_WaitReadOperation();
  *             while(SD_GetStatus() != SD_TRANSFER_OK);
  *
  *             - Add the SDIO and DMA2 StreamX (3 or 6) IRQ Handlers:
  *                 void SDIO_IRQHandler(void)
  *                 {
  *                   SD_ProcessIRQ();
  *                 }
  *                 void SD_SDIO_DMA_IRQHANDLER(void)
  *                 {
  *                   SD_ProcessDMAIRQ();
  *                 }
  *
  *          F - Programming Model (Selecting Polling for SDIO data Transfer)
  *          ================================================================
  *            //Only SD Card Single Block operation are managed.
  *            Status = SD_Init(); // Initialization Step as described in section
  *
  *            // Write operation as described in Section C
  *            Status = SD_WriteBlock(buffer, address, 512);
  *
  *            // Read operation as described in Section B
  *            Status = SD_ReadBlock(buffer, address, 512);
  *
  *          STM32 SDIO Pin assignment
  *          =========================
  *          +-----------------------------------------------------------+
  *          |                     Pin assignment                        |
  *          +-----------------------------+---------------+-------------+
  *          |  STM32 SDIO Pins            |     SD        |    Pin      |
  *          +-----------------------------+---------------+-------------+
  *          |      SDIO D2                |   D2          |    1        |
  *          |      SDIO D3                |   D3          |    2        |
  *          |      SDIO CMD               |   CMD         |    3        |
  *          |                             |   VCC         |    4 (3.3 V)|
  *          |      SDIO CLK               |   CLK         |    5        |
  *          |                             |   GND         |    6 (0 V)  |
  *          |      SDIO D0                |   D0          |    7        |
  *          |      SDIO D1                |   D1          |    8        |
  *          +-----------------------------+---------------+-------------+
  */

/* Includes ------------------------------------------------------------------*/
#include "sdio_sd.h"
#include "main.h"

/**
  * @brief  SDIO Static flags, TimeOut, FIFO Address
  */
#define NULL 0
#define SDIO_STATIC_FLAGS               ((uint32_t)0x000005FF)
#define SDIO_CMD0TIMEOUT                ((uint32_t)0x00010000)


/**
  * @brief  Masks for R6 Response
  */
#define SD_R6_GENERAL_UNKNOWN_ERROR     ((uint32_t)0x00002000)
#define SD_R6_ILLEGAL_CMD               ((uint32_t)0x00004000)
#define SD_R6_COM_CRC_FAILED            ((uint32_t)0x00008000)

#define SD_VOLTAGE_WINDOW_SD            ((uint32_t)0x80100000)
#define SD_HIGH_CAPACITY                ((uint32_t)0x40000000)
#define SD_STD_CAPACITY                 ((uint32_t)0x00000000)
#define SD_CHECK_PATTERN                ((uint32_t)0x000001AA)

#define SD_MAX_VOLT_TRIAL               ((uint32_t)0x0000FFFF)
#define SD_ALLZERO                      ((uint32_t)0x00000000)

#define SD_WIDE_BUS_SUPPORT             ((uint32_t)0x00040000)
#define SD_SINGLE_BUS_SUPPORT           ((uint32_t)0x00010000)
#define SD_CARD_LOCKED                  ((uint32_t)0x02000000)

#define SD_DATATIMEOUT                  ((uint32_t)0xFFFFFFFF)
#define SD_0TO7BITS                     ((uint32_t)0x000000FF)
#define SD_8TO15BITS                    ((uint32_t)0x0000FF00)
#define SD_16TO23BITS                   ((uint32_t)0x00FF0000)
#define SD_24TO31BITS                   ((uint32_t)0xFF000000)
#define SD_MAX_DATA_LENGTH              ((uint32_t)0x01FFFFFF)

#define SD_HALFFIFO                     ((uint32_t)0x00000008)
#define SD_HALFFIFOBYTES                ((uint32_t)0x00000020)

/**
  * @brief  Command Class Supported
  */
#define SD_CCCC_LOCK_UNLOCK             ((uint32_t)0x00000080)
#define SD_CCCC_WRITE_PROT              ((uint32_t)0x00000040)
#define SD_CCCC_ERASE                   ((uint32_t)0x00000020)

/**
  * @brief  Following commands are SD Card Specific commands.
  *         SDIO_APP_CMD should be sent before sending these commands.
  */
#define SDIO_SEND_IF_COND               ((uint32_t)0x00000008)

static uint32_t CardType =  SDIO_STD_CAPACITY_SD_CARD_V1_1;
static uint32_t CSD_Tab[4], CID_Tab[4], RCA = 0;
static uint8_t SDSTATUS_Tab[16];
__IO uint32_t StopCondition = 0;
__IO HAL_SD_ErrorTypedef TransferError = SD_OK;
__IO uint32_t TransferEnd = 0, DMAEndOfTransfer = 0;
SD_CardInfo SDCardInfo;

SDMMC_InitTypeDef SDIO_InitStructure;
SDMMC_CmdInitTypeDef SDIO_CmdInitStructure;
SDMMC_DataInitTypeDef SDIO_DataInitStructure;

uint32_t *pTxBuffPtr;      /*!< Pointer to SD Tx transfer Buffer    */
uint32_t TxXferSize;       /*!< SD Tx Transfer size                 */
uint32_t *pRxBuffPtr;      /*!< Pointer to SD Rx transfer Buffer    */
uint32_t RxXferSize;       /*!< SD Rx Transfer size                 */
/** @defgroup STM32F4_DISCOVERY_SDIO_SD_Private_Function_Prototypes
  * @{
  */
static HAL_SD_ErrorTypedef CmdError(void);
static HAL_SD_ErrorTypedef CmdResp1Error(uint8_t cmd);
static HAL_SD_ErrorTypedef CmdResp7Error(void);
static HAL_SD_ErrorTypedef CmdResp3Error(void);
static HAL_SD_ErrorTypedef CmdResp2Error(void);
static HAL_SD_ErrorTypedef CmdResp6Error(uint8_t cmd, uint16_t *prca);
static HAL_SD_ErrorTypedef SDEnWideBus(FunctionalState NewState);
static HAL_SD_ErrorTypedef IsCardProgramming(uint8_t *pstatus);
static HAL_SD_ErrorTypedef FindSCR(uint16_t rca, uint32_t *pscr);
static uint32_t SDMMC1_Command(uint32_t cmd, uint32_t resp, uint32_t arg);
static void MX_SDMMC1_DMA(void);
uint8_t convert_from_bytes_to_power_of_two(uint16_t NumberOfBytes);

/**
  * @brief  DeInitializes the SDIO interface.
  * @param  None
  * @retval None
  */
void SD_DeInit(void)
{
  SD_LowLevel_DeInit();
}

//SDIO IRQHandler
void SDMMC1_IRQHandler(void)
{
  SD_ProcessIRQSrc();
}

//SDIO_DMA IRQHandler
void DMA2_Stream3_IRQHandler(void)
{
  SD_ProcessDMAIRQ();
}

/**
  * @brief  Initializes the SD Card and put it into StandBy State (Ready for data
  *         transfer).
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_Init(void)
{
  __IO HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t tempreg;

  /* SDIO Peripheral Low Level DeInit */
  SD_DeInit();
  /* SDIO Peripheral Low Level Init */
  SD_LowLevel_Init();

  errorstatus = SD_PowerON();

  if (errorstatus != SD_OK)
  {
    /*!< CMD Response TimeOut (wait for CMDSENT flag) */
    return(errorstatus);
  }

  errorstatus = SD_InitializeCards();

  if (errorstatus != SD_OK)
  {
    /*!< CMD Response TimeOut (wait for CMDSENT flag) */
    return(errorstatus);
  }

  /*!< Configure the SDIO peripheral */
  /*!< SDIO_CK = SDIOCLK / (SDIO_TRANSFER_CLK_DIV + 2) */
  /*!< on STM32F4xx devices, SDIOCLK is fixed to 48MHz */
  tempreg = 0;
  tempreg |= (0x0UL<<14) & SDMMC_CLKCR_HWFC_EN; //SDMMC_HardwareFlowControl_Disable
  tempreg |= (0x0UL<<13) & SDMMC_CLKCR_NEGEDGE; //在 SDMMC_CK 上升沿后的 SDMMCCLK 下降沿更改命令和数据
  tempreg |= (0x0UL<<11) & SDMMC_CLKCR_WIDBUS;  //BusWide_1b
  tempreg |= (0x0UL<<10) & SDMMC_CLKCR_BYPASS;  //SDIO_ClockBypass_Disable
  tempreg |= (0x0UL<<9) & SDMMC_CLKCR_PWRSAV;   //SDIO_ClockPowerSave_Disable 非节能模式始终使能 SDMMC_CK 时钟
  tempreg |= (0x0UL<<8) & SDMMC_CLKCR_CLKEN_Msk;  //SDMMC_CK
  tempreg |= (SDMMC_TRANSFER_CLK_DIV<<0) & SDMMC_CLKCR_CLKDIV;  // 48MHz / (SDMMC_TRANSFER_CLK_DIV + 2) < 25MHz  define in stm32f7xx_ll_sdmmc.h 656
  SDMMC1->CLKCR = tempreg;

  /*----------------- Read CSD/CID MSD registers ------------------*/
  errorstatus = SD_GetCardInfo(&SDCardInfo);

  //if (errorstatus == SD_OK)
  //{
    /*-------------- Select Card ----------A dead loop occurs in this step validation. */
  //  errorstatus = SD_SelectDeselect((uint32_t) (SDCardInfo.RCA << 16));
  //}

  //The above code runs OK, and the following steps are not verified.
  if (errorstatus == SD_OK)
  {
    errorstatus = SD_EnableWideBusOperation(SDMMC_BUS_WIDE_4B); //4 bit data width
  }
  return(errorstatus);
}



void SD_LowLevel_DeInit(void)
{
  uint32_t tempreg;
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  /*!< Disable SDIO Clock */
  tempreg = SDMMC1->CLKCR;
  tempreg &= ~SDMMC_CLKCR_CLKEN; //(uint32_t)1<<8;  //Clock is disable
  SDMMC1->CLKCR = tempreg;

  /*!< Set Power State to OFF */
  SDMMC1->POWER = 0;

  /*!< DeInitializes the SDIO peripheral */
  LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SDMMC1);
  LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SDMMC1);

  /* Disable the SDIO APB2 Clock */
  LL_APB2_GRP1_DisableClock(LL_APB2_GRP1_PERIPH_SDMMC1);

  GPIO_InitStruct.Pin = LL_GPIO_PIN_8|LL_GPIO_PIN_9|LL_GPIO_PIN_10|LL_GPIO_PIN_11|LL_GPIO_PIN_12;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;    // 推挽输出模式
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;    // 无上下拉
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;    // 推挽输出模式
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;    // 无上下拉
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
}

void SD_LowLevel_Init(void)
{
  //uint32_t tempreg;
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOG);

  /**SDIO GPIO Configuration
  PC8    ------> SDMMC_D0
  PC9    ------> SDMMC_D1/I2S_B_CKIN
  PC10   ------> SDMMC_D2
  PC11   ------> SDMMC_D3
  PC12   ------> SDMMC_CK
  PD2    ------> SDMMC_CMD
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_8|LL_GPIO_PIN_9|LL_GPIO_PIN_10|LL_GPIO_PIN_11|LL_GPIO_PIN_12;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;  // 备用功能模式
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;    // 推挽输出模式
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;    // 无上下拉
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;  // 备用功能模式
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;    // 推挽输出模式
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;    // 无上下拉
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*!< Configure SD_DETECT_PIN pin: SD Card detect pin */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
  //GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  LL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /* Enable the SDIO APB2 Clock */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SDMMC1);

  /* Enable the DMA2 Clock */
  //LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA2);

  //Initialize the SDIO (with initial <400Khz Clock)
  //tempreg = 0;  //Reset value
  //tempreg |= SDMMC_CLKCR_CLKEN; //(uint32_t)1<<8;  //Clock is enabled
  //tempreg |= (uint32_t)0x76;  //Clock Divider. Clock=48000/(118+2)=400Khz
  //Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width=0, Power save Disable
  //SDMMC1->CLKCR = tempreg;

  //Power up the SDIO
  //SDMMC1->POWER = 0x03;

  /* Peripheral interrupt init */
  //Configure SDIO Global Interrupt
  NVIC_SetPriority(SDMMC1_IRQn, 5);
  NVIC_EnableIRQ(SDMMC1_IRQn);

  MX_SDMMC1_DMA();
//#ifdef SD_DMA_MODE
  //Configure SDIO_DMA Global Interrupt
//  NVIC_SetPriority(DMA2_Stream4_IRQn, 4);
//  NVIC_EnableIRQ(DMA2_Stream4_IRQn);
//#endif
}

/**
  * @brief  Enquires cards about their operating voltage and configures
  *   clock controls.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_PowerON(void)
{
  __IO HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t response = 0, count = 0, validvoltage = 0;
  uint32_t SDType = SD_STD_CAPACITY;
  uint32_t tempreg = 0;

  /*!< Power ON Sequence -----------------------------------------------------*/
  /*!< Configure the SDIO peripheral */
  /*!< SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) */
  /*!< on STM32F4xx devices, SDIOCLK is fixed to 48MHz */
  /*!< SDIO_CK for initialization should not exceed 400 KHz */
  //Set the DMA CR
  tempreg = 0;
  tempreg |= (0x0UL<<14) & SDMMC_CLKCR_HWFC_EN; //SDMMC_HardwareFlowControl_Disable
  tempreg |= (0x0UL<<13) & SDMMC_CLKCR_NEGEDGE; //在 SDMMC_CK 上升沿后的 SDMMCCLK 下降沿更改命令和数据
  tempreg |= (0x0UL<<11) & SDMMC_CLKCR_WIDBUS;  //BusWide_1b
  tempreg |= (0x0UL<<10) & SDMMC_CLKCR_BYPASS;  //SDIO_ClockBypass_Disable
  tempreg |= (0x0UL<<9) & SDMMC_CLKCR_PWRSAV;   //SDIO_ClockPowerSave_Disable 非节能模式始终使能 SDMMC_CK 时钟
  tempreg |= (0x0UL<<8) & SDMMC_CLKCR_CLKEN_Msk;  //SDMMC_CK
  tempreg |= (0x76UL<<0) & SDMMC_CLKCR_CLKDIV;  //Clock Divider. Clock=48000/(118+2)=400Khz
  //Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width=0, Power save Disable
  SDMMC1->CLKCR = tempreg;

  /*!< Set Power State to ON */
  SDMMC1->POWER = 0x3UL;

  /* 1ms: required power up waiting time before starting the SD initialization sequence */
  //tempreg = 10000;
  //while(tempreg--){}
  HAL_Delay(2);

  /*!< Enable SDIO Clock */
  SDMMC1->CLKCR |= (0x1UL<<8) & SDMMC_CLKCR_CLKEN_Msk;  //SDMMC_CK en


  /*!< CMD0: GO_IDLE_STATE ---------------------------------------------------*/
  /*!< No CMD response required */
  SDMMC1_Command(SDMMC_CMD_GO_IDLE_STATE, SDMMC_RESPONSE_NO, 0);
  errorstatus = CmdError();
  if (errorstatus != SD_OK)
  {
    /*!< CMD Response TimeOut (wait for CMDSENT flag) */
    return(errorstatus);
  }

  /*!< CMD8: SEND_IF_COND ----------------------------------------------------*/
  /*!< Send CMD8 to verify SD card interface operating condition */
  /*!< Argument: - [31:12]: Reserved (shall be set to '0')
               - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
               - [7:0]: Check Pattern (recommended 0xAA) */
  /*!< CMD Response: R7 */
  SDMMC1_Command(SDMMC_CMD_HS_SEND_EXT_CSD, SDMMC_RESPONSE_SHORT, SD_CHECK_PATTERN);
  errorstatus = CmdResp7Error();
  if (errorstatus == SD_OK)
  {
    /* SD Card 2.0 */
    CardType = SDIO_STD_CAPACITY_SD_CARD_V2_0;
    SDType = SD_HIGH_CAPACITY;
  }

  /*!< CMD55 */
  SDMMC1_Command(SDMMC_CMD_APP_CMD, SDMMC_RESPONSE_SHORT, 0x00);
  errorstatus = CmdResp1Error(SDMMC_CMD_APP_CMD);

  /*!< If errorstatus is Command TimeOut, it is a MMC card */
  /*!< If errorstatus is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if (errorstatus == SD_OK)
  {
    /*!< SD CARD */
    /*!< Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      /*!< SEND CMD55 APP_CMD with RCA as 0 */
      SDMMC1_Command(SDMMC_CMD_APP_CMD, SDMMC_RESPONSE_SHORT, 0x00);
      errorstatus = CmdResp1Error(SDMMC_CMD_APP_CMD);
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      //ACMD41
      SDMMC1_Command(SDMMC_CMD_SD_APP_OP_COND, SDMMC_RESPONSE_SHORT, (SD_VOLTAGE_WINDOW_SD | SDType));
      errorstatus = CmdResp3Error();
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      response = SDMMC_GetResponse(SDMMC1, SDMMC_RESP1);
      validvoltage = (((response >> 31) == 1) ? 1 : 0);
      count++;
    }

    if (count >= SD_MAX_VOLT_TRIAL)
    {
      errorstatus = SD_INVALID_VOLTRANGE;
      return(errorstatus);
    }

    if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) //if (response &= SD_HIGH_CAPACITY)
    {
      CardType = SDIO_HIGH_CAPACITY_SD_CARD;
    }

  }/*!< else MMC Card */

  return(errorstatus);
}

static uint32_t SDMMC1_Command(uint32_t cmd, uint32_t resp, uint32_t arg)
{
  //Response must be:
  //0,2:No response (expect cmdsent) ->NORESP
  //1:Short Response  (expect cmdrend and ccrcfail) ->SHRESP
  //3:Long Response   (expect cmdrend and ccrcfail) ->LNRESP

  //uint32_t status;
  //HAL_SD_ErrorTypedef errorstatus = SD_OK;

  //Clear the Command Flags
  //SDMMC1->ICR = (SDMMC_ICR_CCRCFAILC | SDMMC_ICR_CTIMEOUTC | SDMMC_ICR_CMDRENDC | SDMMC_ICR_CMDSENTC);

  SDMMC1->ARG = arg;  //First adjust the argument (because I will immediately enable CPSM next)
  SDMMC1->CMD = (uint32_t)(cmd & SDMMC_CMD_CMDINDEX) | (SDMMC_WAIT_NO & SDMMC_CMD_WAITRESP) | (resp & SDMMC_CMD_WAITRESP) | (0x0400);  //The last argument is to enable CSPM SDMMC_CPSM_ENABLE

  return 0;

#if 0
  //Block till we get a response
  status = SDMMC1->STA;
  if (resp == SDMMC_RESPONSE_NO) {
    //We should wait for CMDSENT
    while (!(status & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CMDSENT)))
    {
      status = SDMMC1->STA;
    }
  }
  else {//SHRESP or LNRESP or R3RESP
    //We should wait for CMDREND or CCRCFAIL
    while (!(status & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CMDREND | SDMMC_STA_CCRCFAIL)))
    {
      status = SDMMC1->STA;
    }
  }

  //Check to see if the response is valid
  //We consider all R3 responses without a timeout as a valid response
  //It seems CMDSENT and CMDREND are mutually exlusive. (though I am not sure. Check this later)
  if (status & SDMMC_STA_CTIMEOUT) {
    errorstatus = SD_CMD_RSP_TIMEOUT;
  }
  else if (status & SDMMC_STA_CCRCFAIL) {
    errorstatus = SD_CMD_CRC_FAIL;
  }

  return errorstatus;
#endif
}
/**
  * @brief  Checks for error conditions for CMD0.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdError(void)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t timeout;
  uint32_t status;

  timeout = SDIO_CMD0TIMEOUT; /*!< 10000 */

  status = SDMMC1->STA;
  while ((timeout > 0) && ((status & SDMMC_STA_CMDSENT) == RESET))
  {
    timeout--;
    status = SDMMC1->STA;
  }

  if (timeout == 0)
  {
    errorstatus = SD_CMD_RSP_TIMEOUT;
    return(errorstatus);
  }

  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;

  return(errorstatus);
}
/**
  * @brief  Checks for error conditions for R7 response.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdResp7Error(void)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t status;
  uint32_t timeout = SDIO_CMD0TIMEOUT;

  status = SDMMC1->STA;
  while (!(status & (SDMMC_STA_CCRCFAIL | SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT)) && (timeout > 0))
  {
    timeout--;
    status = SDMMC1->STA;
  }

  if ((timeout == 0) || (status & SDMMC_STA_CTIMEOUT))
  {
    /*!< Card is not V2.0 complient or card does not support the set voltage range */
    errorstatus = SDMMC_ERROR_CMD_RSP_TIMEOUT;
    SDMMC1->ICR = SDMMC_ICR_CTIMEOUTC;
    return(errorstatus);
  }

  if (status & SDMMC_STA_CMDREND)
  {
    /*!< Card is SD V2.0 compliant */
    errorstatus = SD_OK;
    SDMMC1->ICR = SDMMC_ICR_CMDRENDC;
    return(errorstatus);
  }
  return(errorstatus);
}
/**
  * @brief  Checks for error conditions for R1 response.
  * @param  cmd: The sent command index.
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdResp1Error(uint8_t cmd)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t status;
  uint32_t response_r1;

  status = SDMMC1->STA;

  while (!(status & (SDMMC_STA_CCRCFAIL | SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT)))
  {
    status = SDMMC1->STA;
  }

  if (status & SDMMC_STA_CTIMEOUT)
  {
    errorstatus = SD_CMD_RSP_TIMEOUT;
    SDMMC1->ICR = SDMMC_ICR_CTIMEOUTC;
    return(errorstatus);
  }
  else if (status & SDMMC_STA_CCRCFAIL)
  {
    errorstatus = SD_CMD_CRC_FAIL;
    SDMMC1->ICR = SDMMC_ICR_CCRCFAILC;
    return(errorstatus);
  }

  /*!< Check response received is of desired command */
  if ((SDMMC1->RESPCMD) != cmd)
  {
    errorstatus = SD_ILLEGAL_CMD;
    return(errorstatus);
  }

  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;

  /*!< We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMC1, SDMMC_RESP1);  //stm32f7xx_ll_sdmmc.h 446 SDMMC_RESP1 = 0x00000000U

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SD_ALLZERO)
  {
    return(errorstatus);
  }

  if (response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }

  if (response_r1 & SDMMC_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
  }

  if (response_r1 & SDMMC_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
  }

  if (response_r1 & SDMMC_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
  }

  if (response_r1 & SDMMC_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
  }

  if (response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
  }

  if (response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }

  if (response_r1 & SDMMC_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
  }

  if (response_r1 & SDMMC_OCR_ILLEGAL_CMD)
  {
    return(SD_ILLEGAL_CMD);
  }

  if (response_r1 & SDMMC_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
  }

  if (response_r1 & SDMMC_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
  }

  if (response_r1 & SDMMC_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }

  if (response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
  }

  if (response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) //SD_OCR_STREAM_WRITE_OVERRUN
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }

  if (response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE)//SD_OCR_CID_CSD_OVERWRIETE
  {
    return(SD_CID_CSD_OVERWRITE);
  }

  if (response_r1 & SDMMC_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
  }

  if (response_r1 & SDMMC_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
  }

  if (response_r1 & SDMMC_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
  }

  if (response_r1 & SDMMC_OCR_AKE_SEQ_ERROR)
  {
    return(SD_AKE_SEQ_ERROR);
  }
  return(errorstatus);
}
/**
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdResp3Error(void)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t status;

  status = SDMMC1->STA;

  while (!(status & (SDMMC_STA_CCRCFAIL | SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT)))
  {
    status = SDMMC1->STA;
  }

  if (status & SDMMC_STA_CTIMEOUT)
  {
    errorstatus = SD_CMD_RSP_TIMEOUT;
    SDMMC1->ICR = SDMMC_ICR_CTIMEOUTC;
    return(errorstatus);
  }
  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;
  return(errorstatus);
}
/**
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdResp2Error(void)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t status;

  status = SDMMC1->STA;

  while (!(status & (SDMMC_STA_CCRCFAIL | SDMMC_STA_CTIMEOUT | SDMMC_STA_CMDREND)))
  {
    status = SDMMC1->STA;
  }

  if (status & SDMMC_STA_CTIMEOUT)
  {
    errorstatus = SD_CMD_RSP_TIMEOUT;
    SDMMC1->ICR = SDMMC_ICR_CTIMEOUTC;
    return(errorstatus);
  }
  else if (status & SDMMC_STA_CCRCFAIL)
  {
    errorstatus = SD_CMD_CRC_FAIL;
    SDMMC1->ICR = SDMMC_ICR_CCRCFAILC;
    return(errorstatus);
  }

  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;

  return(errorstatus);
}
/**
  * @brief  Checks for error conditions for R6 (RCA) response.
  * @param  cmd: The sent command index.
  * @param  prca: pointer to the variable that will contain the SD card relative
  *         address RCA.
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef CmdResp6Error(uint8_t cmd, uint16_t *prca)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t status;
  uint32_t response_r1;

  status = SDMMC1->STA;

  while (!(status & (SDMMC_STA_CCRCFAIL | SDMMC_STA_CTIMEOUT | SDMMC_STA_CMDREND)))
  {
    status = SDMMC1->STA;
  }

  if (status & SDMMC_STA_CTIMEOUT)
  {
    errorstatus = SD_CMD_RSP_TIMEOUT;
    SDMMC1->ICR = SDMMC_ICR_CTIMEOUTC;
    return(errorstatus);
  }
  else if (status & SDMMC_STA_CCRCFAIL)
  {
    errorstatus = SD_CMD_CRC_FAIL;
    SDMMC1->ICR = SDMMC_ICR_CCRCFAILC;
    return(errorstatus);
  }

  /*!< Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMC1) != cmd)
  {
    errorstatus = SD_ILLEGAL_CMD;
    return(errorstatus);
  }

  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;

  /*!< We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMC1, SDMMC_RESP1);

  if (SD_ALLZERO == (response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)))
  {
    *prca = (uint16_t) (response_r1 >> 16);
    return(errorstatus);
  }

  if (response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }

  if (response_r1 & SD_R6_ILLEGAL_CMD)
  {
    return(SD_ILLEGAL_CMD);
  }

  if (response_r1 & SD_R6_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
  }

  return(errorstatus);
}
/**
  * @brief  Intialises all cards or single card as the case may be Card(s) come
  *         into standby state.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_InitializeCards(void)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint16_t rca = 0x01;

  if (SDMMC_GetPowerState(SDMMC1) == 0) //SDIO_PowerState_OFF
  {
    errorstatus = SD_REQUEST_NOT_APPLICABLE;
    return(errorstatus);
  }

  if (CardType != SDIO_SECURE_DIGITAL_IO_CARD)
  {
    /*!< Send CMD2 ALL_SEND_CID */
    SDMMC1_Command(SDMMC_CMD_ALL_SEND_CID, SDMMC_RESPONSE_LONG, 0x00);
    errorstatus = CmdResp2Error();

    if (SD_OK != errorstatus)
    {
      return(errorstatus);
    }
    /* Get Card identification number data */
    CID_Tab[0] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP1);
    CID_Tab[1] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP2);
    CID_Tab[2] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP3);
    CID_Tab[3] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP4);
  }
  if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType)
      || (SDIO_SECURE_DIGITAL_IO_COMBO_CARD == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
  {
    /*!< Send CMD3 SET_REL_ADDR with argument 0 */
    /*!< SD Card publishes its RCA. */
    SDMMC1_Command(SDMMC_CMD_SET_REL_ADDR, SDMMC_RESPONSE_SHORT, 0x00);
    errorstatus = CmdResp6Error(SDMMC_CMD_SET_REL_ADDR, &rca);

    if (SD_OK != errorstatus)
    {
      return(errorstatus);
    }
  }

  if (SDIO_SECURE_DIGITAL_IO_CARD != CardType)
  {
    RCA = rca;

    /*!< Send CMD9 SEND_CSD with argument as card's RCA */
    SDMMC1_Command(SDMMC_CMD_SEND_CSD, SDMMC_RESPONSE_LONG, (uint32_t)(rca << 16));
    errorstatus = CmdResp2Error();

    if (SD_OK != errorstatus)
    {
      return(errorstatus);
    }

    /* Get Card Specific Data */
    CID_Tab[0] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP1);
    CID_Tab[1] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP2);
    CID_Tab[2] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP3);
    CID_Tab[3] = SDMMC_GetResponse(SDMMC1, SDMMC_RESP4);
  }

  errorstatus = SD_OK; /*!< All cards get intialized */

  return(errorstatus);
}

/**
  * @brief  Returns information about specific card.
  * @param  cardinfo: pointer to a SD_CardInfo structure that contains all SD card
  *         information.
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_GetCardInfo(SD_CardInfo *cardinfo)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint8_t tmp = 0;

  cardinfo->CardType = (uint8_t)CardType;
  cardinfo->RCA = (uint16_t)RCA;

  /*!< Byte 0 */
  tmp = (uint8_t)((CSD_Tab[0] & 0xFF000000) >> 24);
  cardinfo->SD_csd.CSDStruct = (tmp & 0xC0) >> 6;
  cardinfo->SD_csd.SysSpecVersion = (tmp & 0x3C) >> 2;
  cardinfo->SD_csd.Reserved1 = tmp & 0x03;

  /*!< Byte 1 */
  tmp = (uint8_t)((CSD_Tab[0] & 0x00FF0000) >> 16);
  cardinfo->SD_csd.TAAC = tmp;

  /*!< Byte 2 */
  tmp = (uint8_t)((CSD_Tab[0] & 0x0000FF00) >> 8);
  cardinfo->SD_csd.NSAC = tmp;

  /*!< Byte 3 */
  tmp = (uint8_t)(CSD_Tab[0] & 0x000000FF);
  cardinfo->SD_csd.MaxBusClkFrec = tmp;

  /*!< Byte 4 */
  tmp = (uint8_t)((CSD_Tab[1] & 0xFF000000) >> 24);
  cardinfo->SD_csd.CardComdClasses = tmp << 4;

  /*!< Byte 5 */
  tmp = (uint8_t)((CSD_Tab[1] & 0x00FF0000) >> 16);
  cardinfo->SD_csd.CardComdClasses |= (tmp & 0xF0) >> 4;
  cardinfo->SD_csd.RdBlockLen = tmp & 0x0F;

  /*!< Byte 6 */
  tmp = (uint8_t)((CSD_Tab[1] & 0x0000FF00) >> 8);
  cardinfo->SD_csd.PartBlockRead = (tmp & 0x80) >> 7;
  cardinfo->SD_csd.WrBlockMisalign = (tmp & 0x40) >> 6;
  cardinfo->SD_csd.RdBlockMisalign = (tmp & 0x20) >> 5;
  cardinfo->SD_csd.DSRImpl = (tmp & 0x10) >> 4;
  cardinfo->SD_csd.Reserved2 = 0; /*!< Reserved */

  if ((CardType == SDIO_STD_CAPACITY_SD_CARD_V1_1) || (CardType == SDIO_STD_CAPACITY_SD_CARD_V2_0))
  {
    cardinfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;

    /*!< Byte 7 */
    tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    cardinfo->SD_csd.DeviceSize |= (tmp) << 2;

    /*!< Byte 8 */
    tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
    cardinfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;

    cardinfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
    cardinfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);

    /*!< Byte 9 */
    tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
    cardinfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
    cardinfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
    cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
    /*!< Byte 10 */
    tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
    cardinfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;

    cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
    cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
    cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
    cardinfo->CardCapacity *= cardinfo->CardBlockSize;
  }
  else if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
  {
    /*!< Byte 7 */
    tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    cardinfo->SD_csd.DeviceSize = (tmp & 0x3F) << 16;

    /*!< Byte 8 */
    tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);

    cardinfo->SD_csd.DeviceSize |= (tmp << 8);

    /*!< Byte 9 */
    tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);

    cardinfo->SD_csd.DeviceSize |= (tmp);

    /*!< Byte 10 */
    tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);

    cardinfo->CardCapacity = (uint64_t)(cardinfo->SD_csd.DeviceSize + 1) * (uint64_t)(512 * 1024);
    cardinfo->CardBlockSize = 512;
  }

  cardinfo->SD_csd.EraseGrSize = (tmp & 0x40) >> 6;
  cardinfo->SD_csd.EraseGrMul = (tmp & 0x3F) << 1;

  /*!< Byte 11 */
  tmp = (uint8_t)(CSD_Tab[2] & 0x000000FF);
  cardinfo->SD_csd.EraseGrMul |= (tmp & 0x80) >> 7;
  cardinfo->SD_csd.WrProtectGrSize = (tmp & 0x7F);

  /*!< Byte 12 */
  tmp = (uint8_t)((CSD_Tab[3] & 0xFF000000) >> 24);
  cardinfo->SD_csd.WrProtectGrEnable = (tmp & 0x80) >> 7;
  cardinfo->SD_csd.ManDeflECC = (tmp & 0x60) >> 5;
  cardinfo->SD_csd.WrSpeedFact = (tmp & 0x1C) >> 2;
  cardinfo->SD_csd.MaxWrBlockLen = (tmp & 0x03) << 2;

  /*!< Byte 13 */
  tmp = (uint8_t)((CSD_Tab[3] & 0x00FF0000) >> 16);
  cardinfo->SD_csd.MaxWrBlockLen |= (tmp & 0xC0) >> 6;
  cardinfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20) >> 5;
  cardinfo->SD_csd.Reserved3 = 0;
  cardinfo->SD_csd.ContentProtectAppli = (tmp & 0x01);

  /*!< Byte 14 */
  tmp = (uint8_t)((CSD_Tab[3] & 0x0000FF00) >> 8);
  cardinfo->SD_csd.FileFormatGrouop = (tmp & 0x80) >> 7;
  cardinfo->SD_csd.CopyFlag = (tmp & 0x40) >> 6;
  cardinfo->SD_csd.PermWrProtect = (tmp & 0x20) >> 5;
  cardinfo->SD_csd.TempWrProtect = (tmp & 0x10) >> 4;
  cardinfo->SD_csd.FileFormat = (tmp & 0x0C) >> 2;
  cardinfo->SD_csd.ECC = (tmp & 0x03);

  /*!< Byte 15 */
  tmp = (uint8_t)(CSD_Tab[3] & 0x000000FF);
  cardinfo->SD_csd.CSD_CRC = (tmp & 0xFE) >> 1;
  cardinfo->SD_csd.Reserved4 = 1;


  /*!< Byte 0 */
  tmp = (uint8_t)((CID_Tab[0] & 0xFF000000) >> 24);
  cardinfo->SD_cid.ManufacturerID = tmp;

  /*!< Byte 1 */
  tmp = (uint8_t)((CID_Tab[0] & 0x00FF0000) >> 16);
  cardinfo->SD_cid.OEM_AppliID = tmp << 8;

  /*!< Byte 2 */
  tmp = (uint8_t)((CID_Tab[0] & 0x000000FF00) >> 8);
  cardinfo->SD_cid.OEM_AppliID |= tmp;

  /*!< Byte 3 */
  tmp = (uint8_t)(CID_Tab[0] & 0x000000FF);
  cardinfo->SD_cid.ProdName1 = tmp << 24;

  /*!< Byte 4 */
  tmp = (uint8_t)((CID_Tab[1] & 0xFF000000) >> 24);
  cardinfo->SD_cid.ProdName1 |= tmp << 16;

  /*!< Byte 5 */
  tmp = (uint8_t)((CID_Tab[1] & 0x00FF0000) >> 16);
  cardinfo->SD_cid.ProdName1 |= tmp << 8;

  /*!< Byte 6 */
  tmp = (uint8_t)((CID_Tab[1] & 0x0000FF00) >> 8);
  cardinfo->SD_cid.ProdName1 |= tmp;

  /*!< Byte 7 */
  tmp = (uint8_t)(CID_Tab[1] & 0x000000FF);
  cardinfo->SD_cid.ProdName2 = tmp;

  /*!< Byte 8 */
  tmp = (uint8_t)((CID_Tab[2] & 0xFF000000) >> 24);
  cardinfo->SD_cid.ProdRev = tmp;

  /*!< Byte 9 */
  tmp = (uint8_t)((CID_Tab[2] & 0x00FF0000) >> 16);
  cardinfo->SD_cid.ProdSN = tmp << 24;

  /*!< Byte 10 */
  tmp = (uint8_t)((CID_Tab[2] & 0x0000FF00) >> 8);
  cardinfo->SD_cid.ProdSN |= tmp << 16;

  /*!< Byte 11 */
  tmp = (uint8_t)(CID_Tab[2] & 0x000000FF);
  cardinfo->SD_cid.ProdSN |= tmp << 8;

  /*!< Byte 12 */
  tmp = (uint8_t)((CID_Tab[3] & 0xFF000000) >> 24);
  cardinfo->SD_cid.ProdSN |= tmp;

  /*!< Byte 13 */
  tmp = (uint8_t)((CID_Tab[3] & 0x00FF0000) >> 16);
  cardinfo->SD_cid.Reserved1 |= (tmp & 0xF0) >> 4;
  cardinfo->SD_cid.ManufactDate = (tmp & 0x0F) << 8;

  /*!< Byte 14 */
  tmp = (uint8_t)((CID_Tab[3] & 0x0000FF00) >> 8);
  cardinfo->SD_cid.ManufactDate |= tmp;

  /*!< Byte 15 */
  tmp = (uint8_t)(CID_Tab[3] & 0x000000FF);
  cardinfo->SD_cid.CID_CRC = (tmp & 0xFE) >> 1;
  cardinfo->SD_cid.Reserved2 = 1;

  return(errorstatus);
}

/**
  * @brief  Selects od Deselects the corresponding card.
  * @param  addr: Address of the Card to be selected.
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_SelectDeselect(uint32_t addr)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;

  /*!< Send CMD7 SDIO_SEL_DESEL_CARD */
  SDMMC1_Command(SDMMC_CMD_SEL_DESEL_CARD, SDMMC_RESPONSE_SHORT, addr);
  errorstatus = CmdResp1Error(SDMMC_CMD_SEL_DESEL_CARD);

  return(errorstatus);
}
/**
  * @brief  Enables wide bus opeartion for the requeseted card if supported by
  *         card.
  * @param  WideMode: Specifies the SD card wide bus mode.
  *   This parameter can be one of the following values:
  *     @arg SDIO_BusWide_8b: 8-bit data transfer (Only for MMC)
  *     @arg SDIO_BusWide_4b: 4-bit data transfer
  *     @arg SDIO_BusWide_1b: 1-bit data transfer
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_EnableWideBusOperation(uint32_t WideMode)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t tempreg;

  /*!< MMC Card doesn't support this feature */
  if (SDIO_MULTIMEDIA_CARD == CardType)
  {
    errorstatus = SD_UNSUPPORTED_FEATURE;
    return(errorstatus);
  }
  else if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
  {
    if (SDMMC_BUS_WIDE_8B == WideMode) //SDMMC_BUS_WIDE_8B  SDIO_BusWide_8b
    {
      errorstatus = SD_UNSUPPORTED_FEATURE;
      return(errorstatus);
    }
    else if (SDMMC_BUS_WIDE_4B == WideMode)
    {
      errorstatus = SDEnWideBus(ENABLE);

      if (SD_OK == errorstatus)
      {
        /*!< Configure the SDIO peripheral */
        tempreg = 0;
        tempreg |= (0x0UL<<14) & SDMMC_CLKCR_HWFC_EN; //SDMMC_HardwareFlowControl_Disable
        tempreg |= (0x0UL<<13) & SDMMC_CLKCR_NEGEDGE; //在 SDMMC_CK 上升沿后的 SDMMCCLK 下降沿更改命令和数据
        tempreg |= (0x1UL<<11) & SDMMC_CLKCR_WIDBUS;  //SDMMC_BUS_WIDE_4B
        tempreg |= (0x0UL<<10) & SDMMC_CLKCR_BYPASS;  //SDIO_ClockBypass_Disable
        tempreg |= (0x0UL<<9) & SDMMC_CLKCR_PWRSAV;   //SDIO_ClockPowerSave_Disable 非节能模式始终使能 SDMMC_CK 时钟
        tempreg |= (0x0UL<<8) & SDMMC_CLKCR_CLKEN_Msk;  //SDMMC_CK
        tempreg |= (SDMMC_TRANSFER_CLK_DIV<<0) & SDMMC_CLKCR_CLKDIV;  // 48MHz / (SDMMC_TRANSFER_CLK_DIV + 2) < 25MHz  define in stm32f7xx_ll_sdmmc.h 656
        SDMMC1->CLKCR = tempreg;
      }
    }
    else
    {
      errorstatus = SDEnWideBus(DISABLE);

      if (SD_OK == errorstatus)
      {
        tempreg = 0;
        tempreg |= (0x0UL<<14) & SDMMC_CLKCR_HWFC_EN; //SDMMC_HardwareFlowControl_Disable
        tempreg |= (0x0UL<<13) & SDMMC_CLKCR_NEGEDGE; //在 SDMMC_CK 上升沿后的 SDMMCCLK 下降沿更改命令和数据
        tempreg |= (0x0UL<<11) & SDMMC_CLKCR_WIDBUS;  //SDMMC_BUS_WIDE_1B
        tempreg |= (0x0UL<<10) & SDMMC_CLKCR_BYPASS;  //SDIO_ClockBypass_Disable
        tempreg |= (0x0UL<<9) & SDMMC_CLKCR_PWRSAV;   //SDIO_ClockPowerSave_Disable 非节能模式始终使能 SDMMC_CK 时钟
        tempreg |= (0x0UL<<8) & SDMMC_CLKCR_CLKEN_Msk;  //SDMMC_CK
        tempreg |= (SDMMC_TRANSFER_CLK_DIV<<0) & SDMMC_CLKCR_CLKDIV;  // 48MHz / (SDMMC_TRANSFER_CLK_DIV + 2) < 25MHz  define in stm32f7xx_ll_sdmmc.h 656
        SDMMC1->CLKCR = tempreg;
      }
    }
  }

  return(errorstatus);
}
/**
  * @brief  Enables or disables the SDIO wide bus mode.
  * @param  NewState: new state of the SDIO wide bus mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef SDEnWideBus(FunctionalState NewState)
{
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t scr[2] = {0, 0};

  if (SDMMC_GetResponse(SDMMC1, SDMMC_RESP1) & SD_CARD_LOCKED)
  {
    errorstatus = SD_LOCK_UNLOCK_FAILED;
    return(errorstatus);
  }

  /*!< Get SCR Register */
  errorstatus = FindSCR(RCA, scr);
  if (errorstatus != SD_OK)
  {
    return(errorstatus);
  }

  /*!< If wide bus operation to be enabled */
  if (NewState == ENABLE)
  {
    /*!< If requested card supports wide bus operation */
    if ((scr[1] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
    {
      /*!< Send CMD55 APP_CMD with argument as card's RCA.*/
      SDMMC1_Command(SDMMC_CMD_APP_CMD, SDMMC_RESPONSE_SHORT, ((uint32_t) RCA << 16));
      errorstatus = CmdResp1Error(SDMMC_CMD_APP_CMD);
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      /*!< Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
      SDMMC1_Command(SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_RESPONSE_SHORT, 0x2);
      errorstatus = CmdResp1Error(SDMMC_CMD_APP_SD_SET_BUSWIDTH);
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      return(errorstatus);
    }
    else
    {
      errorstatus = SD_REQUEST_NOT_APPLICABLE;
      return(errorstatus);
    }
  }   /*!< If wide bus operation to be disabled */
  else
  {
    /*!< If requested card supports 1 bit mode operation */
    if ((scr[1] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
    {
      /*!< Send CMD55 APP_CMD with argument as card's RCA.*/
      SDMMC1_Command(SDMMC_CMD_APP_CMD, SDMMC_RESPONSE_SHORT, ((uint32_t) RCA << 16));
      errorstatus = CmdResp1Error(SDMMC_CMD_APP_CMD);
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      /*!< Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
      SDMMC1_Command(SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_RESPONSE_SHORT, 0x0);
      errorstatus = CmdResp1Error(SD_CMD_APP_SD_SET_BUSWIDTH);
      if (errorstatus != SD_OK)
      {
        return(errorstatus);
      }

      return(errorstatus);
    }
    else
    {
      errorstatus = SD_REQUEST_NOT_APPLICABLE;
      return(errorstatus);
    }
  }
}
/**
  * @brief  Find the SD card SCR register value.
  * @param  rca: selected card address.
  * @param  pscr: pointer to the buffer that will contain the SCR value.
  * @retval SD_Error: SD Card Error code.
  */
static HAL_SD_ErrorTypedef FindSCR(uint16_t rca, uint32_t *pscr)
{
  uint32_t tmpreg, index = 0;
  HAL_SD_ErrorTypedef errorstatus = SD_OK;
  uint32_t tempscr[2] = {0, 0};

  /*!< Set Block Size To 8 Bytes */
  /*!< Send CMD55 APP_CMD with argument as card's RCA */
  SDMMC1_Command(SDMMC_CMD_SET_BLOCKLEN, SDMMC_RESPONSE_SHORT, (uint32_t)8);
  errorstatus = CmdResp1Error(SDMMC_CMD_SET_BLOCKLEN);

  if (errorstatus != SD_OK)
  {
    return(errorstatus);
  }

  /*!< Send CMD55 APP_CMD with argument as card's RCA */
  SDMMC1_Command(SDMMC_CMD_APP_CMD, SDMMC_RESPONSE_SHORT, ((uint32_t) rca << 16));
  errorstatus = CmdResp1Error(SDMMC_CMD_APP_CMD);

  if (errorstatus != SD_OK)
  {
    return(errorstatus);
  }
  //SDIO_DataInitStructure.DataTimeOut = SD_DATATIMEOUT;
  //SDIO_DataInitStructure.DataLength = 8;
  //SDIO_DataInitStructure.DataBlockSize = SDIO_DataBlockSize_8b;
  //SDIO_DataInitStructure.TransferDir = SDIO_TransferDir_ToSDIO;
  //SDIO_DataInitStructure.TransferMode = SDIO_TransferMode_Block;
  //SDIO_DataInitStructure.DPSM = SDIO_DPSM_Enable;
  //SDMMC_ConfigData(SDMMC1, &SDIO_DataInitStructure);
  /* Set the SDMMC Data TimeOut value */
  SDMMC1->DTIMER = SD_DATATIMEOUT;
  /* Set the SDMMC DataLength value */
  SDMMC1->DLEN = 8;
  /* Get the SDIO DCTRL value */
  tmpreg = SDMMC1->DCTRL;
  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
  tmpreg &= ((uint32_t)0xFFFFFF08);
  /* Set the SDMMC data configuration parameters */
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (SDMMC_DATABLOCK_SIZE_8B<<4) & SDMMC_DCTRL_DBLOCKSIZE;  //data block length when the block data transfer mode is selected
  tmpreg |= (0x0UL<<2) & SDMMC_DCTRL_DTMODE; //0: Block data transfer 1: Stream or SDIO multibyte data transfer
  tmpreg |= (0x1UL<<1) & SDMMC_DCTRL_DTDIR;  //Data transfer direction selection. from sdcard to mcu
  tmpreg |= (0x1UL<<0) & SDMMC_DCTRL_DTEN;   //Data transfer enabled bit
  /* Write to SDMMC DCTRL */
  SDMMC1->DCTRL = tmpreg;

  /*!< Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  SDMMC1_Command(SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_RESPONSE_SHORT, 0x0);
  errorstatus = CmdResp1Error(SDMMC_CMD_SD_APP_SEND_SCR);

  if (errorstatus != SD_OK)
  {
    return(errorstatus);
  }

  tmpreg = SDMMC1->STA;
  while (!(tmpreg & (SDMMC_STA_RXOVERR | SDMMC_STA_DCRCFAIL | SDMMC_STA_DTIMEOUT | SDMMC_STA_DBCKEND))) //| SDMMC_STA_STBITERR
  {
    tmpreg = SDMMC1->STA;
    if ((tmpreg & SDMMC_STA_RXOVERR) != RESET)
    {
      *(tempscr + index) = SDMMC1->FIFO;
      index++;
    }
  }

  tmpreg = SDMMC1->STA;
  if ((tmpreg & SDMMC_STA_DTIMEOUT) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_DTIMEOUTC;
    errorstatus = SD_DATA_TIMEOUT;
    return(errorstatus);
  }
  else if ((tmpreg & SDMMC_STA_DCRCFAIL) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_DCRCFAILC;
    errorstatus = SD_DATA_CRC_FAIL;
    return(errorstatus);
  }
  else if ((tmpreg & SDMMC_STA_RXOVERR) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_RXOVERRC;
    errorstatus = SD_RX_OVERRUN;
    return(errorstatus);
  }
  //else if ((tempreg & SDMMC_STA_STBITERR) != RESET)
  //{
  //  SDIO_ClearFlag(SDIO_FLAG_STBITERR);
  //  errorstatus = SD_START_BIT_ERR;
  //  return(errorstatus);
  //}

  /*!< Clear all the static flags */
  SDMMC1->ICR = SDIO_STATIC_FLAGS;

  *(pscr + 1) = ((tempscr[0] & SD_0TO7BITS) << 24) | ((tempscr[0] & SD_8TO15BITS) << 8) | ((tempscr[0] & SD_16TO23BITS) >> 8) | ((tempscr[0] & SD_24TO31BITS) >> 24);

  *(pscr) = ((tempscr[1] & SD_0TO7BITS) << 24) | ((tempscr[1] & SD_8TO15BITS) << 8) | ((tempscr[1] & SD_16TO23BITS) >> 8) | ((tempscr[1] & SD_24TO31BITS) >> 24);

  return(errorstatus);
}

static void MX_SDMMC1_DMA(void)
{
  /* DMA2 used for SDMMC1 Transmission and Reception
   */
  /* (1) Enable the clock of DMA2 */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA2);

  /* (2) Configure NVIC for DMA transfer complete/error interrupts */
  NVIC_SetPriority(DMA2_Stream3_IRQn, 6); //0
  NVIC_EnableIRQ(DMA2_Stream3_IRQn);
  NVIC_SetPriority(DMA2_Stream6_IRQn, 6); //0
  NVIC_EnableIRQ(DMA2_Stream6_IRQn);

  /* (3) Configure the DMA functional DMA Rx parameters for transmission */
  LL_DMA_SetChannelSelection(DMA2, LL_DMA_STREAM_3, LL_DMA_CHANNEL_4);
  LL_DMA_ConfigTransfer(DMA2, LL_DMA_STREAM_3,
                        LL_DMA_DIRECTION_PERIPH_TO_MEMORY |  /*设备 to memory bit:6  */
						LL_DMA_PRIORITY_HIGH              |  /*优先级   */
						LL_DMA_MODE_PFCTRL                |  /*外设流量控制模式   */
                        LL_DMA_PERIPH_NOINCREMENT         |  /*外设地址指针固定，不增量 bit:9  */
						LL_DMA_MEMORY_INCREMENT           |  /*memory地址指针增量   */
						LL_DMA_PDATAALIGN_WORD            |  /*外设数据大小32位，bit:12-11   */
						LL_DMA_PDATAALIGN_WORD);             /*memory数据大小32位，bit:14-13   */
  LL_DMA_ConfigAddresses(DMA2, LL_DMA_STREAM_3,
                         (uint32_t) &(SDMMC1->FIFO),
						 (uint32_t)pRxBuffPtr,
                         LL_DMA_GetDataTransferDirection(DMA2, LL_DMA_STREAM_3));
  //LL_DMA_SetDataLength(DMA2, LL_DMA_STREAM_3, ubNbDataToTransmit);

  /* (4) Configure the DMA functional parameters for reception */
  LL_DMA_SetChannelSelection(DMA2, LL_DMA_STREAM_6, LL_DMA_CHANNEL_4);
  LL_DMA_ConfigTransfer(DMA1, LL_DMA_STREAM_6,
                        LL_DMA_DIRECTION_MEMORY_TO_PERIPH |
						LL_DMA_PRIORITY_HIGH              |
						LL_DMA_MODE_PFCTRL                |
                        LL_DMA_PERIPH_NOINCREMENT         |
						LL_DMA_MEMORY_INCREMENT           |
						LL_DMA_PDATAALIGN_WORD            |
						LL_DMA_PDATAALIGN_WORD);
  LL_DMA_ConfigAddresses(DMA2, LL_DMA_STREAM_6,
		                 (uint32_t)pTxBuffPtr,
						 (uint32_t) &(SDMMC1->FIFO),
                         LL_DMA_GetDataTransferDirection(DMA2, LL_DMA_STREAM_6));
  //LL_DMA_SetDataLength(DMA2, LL_DMA_STREAM_6, ubNbDataToReceive);

  /* (5) Enable DMA transfer complete/error interrupts  */
  LL_DMA_EnableIT_TC(DMA2, LL_DMA_STREAM_3);
  //LL_DMA_EnableIT_TE(DMA2, LL_DMA_STREAM_3);
  LL_DMA_EnableIT_TC(DMA2, LL_DMA_STREAM_6);
  //LL_DMA_EnableIT_TE(DMA2, LL_DMA_STREAM_6);

}
/**
  * @brief  Allows to process all the interrupts that are high.
  * @param  None
  * @retval SD_Error: SD Card Error code.
  */
HAL_SD_ErrorTypedef SD_ProcessIRQSrc(void)
{
  if ((SDMMC1->STA  & SDMMC_STA_DATAEND) != RESET)
  {
    TransferError = SD_OK;
    SDMMC1->ICR = SDMMC_ICR_DATAENDC;
    TransferEnd = 1;
  }
  else if ((SDMMC1->STA  & SDMMC_STA_DCRCFAIL) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_DCRCFAILC;
    TransferError = SD_DATA_CRC_FAIL;
  }
  else if ((SDMMC1->STA  & SDMMC_STA_DTIMEOUT) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_DTIMEOUTC;
    TransferError = SD_DATA_TIMEOUT;
  }
  else if ((SDMMC1->STA  & SDMMC_STA_RXOVERR) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_RXOVERRC;
    TransferError = SD_RX_OVERRUN;
  }
  else if ((SDMMC1->STA  & SDMMC_STA_TXUNDERR) != RESET)
  {
    SDMMC1->ICR = SDMMC_ICR_TXUNDERRC;
    TransferError = SD_TX_UNDERRUN;
  }
  //else if (SDIO_GetITStatus(SDIO_IT_STBITERR) != RESET)
  //{
  //  SDIO_ClearITPendingBit(SDIO_IT_STBITERR);
  //  TransferError = SD_START_BIT_ERR;
  //}
  SDMMC1->MASK &= ~(SDMMC_MASK_DCRCFAILIE | SDMMC_MASK_DTIMEOUTIE | SDMMC_MASK_DATAENDIE |
		            SDMMC_MASK_TXFIFOHEIE | SDMMC_MASK_RXFIFOHFIE | SDMMC_MASK_TXUNDERRIE | SDMMC_MASK_RXOVERRIE);

  return(TransferError);
}

/**
  * @brief  This function waits until the SDIO DMA data transfer is finished.
  * @param  None.
  * @retval None.
  */
void SD_ProcessDMAIRQ(void)
{
  if(DMA2->LISR & SD_SDIO_DMA_FLAG_TCIF) //数据流发生传输完成事件
  {
    DMAEndOfTransfer = 0x01;
    DMA2->LIFCR = SD_SDIO_DMA_FLAG_TCIF|SD_SDIO_DMA_FLAG_FEIF;
    //DMA_ClearFlag(SD_SDIO_DMA_STREAM, SD_SDIO_DMA_FLAG_TCIF|SD_SDIO_DMA_FLAG_FEIF);
  }
}


/////////////////////////////////////////////////////////////////////



#if 0


static uint32_t SD_Response(uint32_t *response, uint32_t type)
{
  //I mainly use this to block the execution in case an unexpected response is received.
  //Actually I don't need this at all. However, just for the sake of extra information I keep this.
  //All I reall need is for this function to return SDIO->RESP1
  //In the main code, I don't use the retun values at all. Perhaps I ought to have used void.
  uint32_t tempreg = 0;

  //R1 Responses
  if ((type == RESP_R1) || (type == RESP_R1b)) {
    //tempreg = SDMMC1->RESPCMD;
    //if(tempreg != 55)
    //  return tempreg;
    *response = SDMMC1->RESP1;
    tempreg = SDMMC1->RESP1;
    //if (SDMMC1->RESP1 & (uint32_t)0xFDFFE008) {   //All error bits must be zero
    if (tempreg & (uint32_t)0xFDFFE008) {
      SD_Panic(SDMMC1->RESPCMD, "SDIO:Response Error\n");
    }
    return (*response & 0x1F00)>>8; //Return the card status
  }
  else if (type == RESP_R2) { //CSD or CSI register. 128 bit
    *response++ = SDMMC1->RESP1;
    *response++ = SDMMC1->RESP2;
    *response++ = SDMMC1->RESP3;
    *response = SDMMC1->RESP4;
    return 0;
  }
  else if (type == RESP_R3) { //OCR
    if (SDMMC1->RESPCMD != 0x3F) {SD_Panic(SDMMC1->RESPCMD,"SDIO:Unexpected command index\n");} //CMD index for R3 must be 0x3F
    *response = SDMMC1->RESP1;  //Equals to OCR
    return 0;
  }
  else if (type==RESP_R6) { //RCA Response
    if (SDMMC1->RESPCMD != 0x03) {SD_Panic(SDMMC1->RESPCMD,"SDIO:Unexpected command index\n");} //Only cmd3 generates R6 response
    *response=SDMMC1->RESP1;  //Equals to OCR
    return (*response)>>16; //Return is equal to RCA. (The first 16 bit is equal to status)
  }
  else {  //RESP_R7:Card Interface condition. Obtained after CMD8
    if (SDMMC1->RESPCMD != 0x08) {SD_Panic(SDMMC1->RESPCMD,"SDIO:Unexpected command index\n");} //Only cmd8 generates R7 response
    *response = SDMMC1->RESP1;
    if ((*response & 0xFF) != 0xAA) {SD_Panic(CMD8, "SDIO:Pattern did not match\n");} //Only cmd8 generates R7 response
    return ((*response) & 0xFF00)>>8; //Echo back value
  }
}

static void SD_StartBlockTransfer(uint8_t *buf, uint32_t cnt, uint32_t dir)
{
  //cnt must be integer multiple of 512!!! I will enforce this inside this function
  //Starts the actual data tranfer using the DMA.
  //Prior to calling this command. The SDCard must have been adjusted using commands
  uint32_t tempreg;

  //Make cnt an integer multiple of 512
  //Then mask it with the maximum value allowed (2^24)
  cnt = 0x01FFFFFF & ((cnt>>8) << 8);

  /////PART I::::Adjust the DMA
  //Reset the control register (0x00 is the default value. this also disables the dma. When EN=0, it stops any ongoing DMA transfer)
  DMA2_Stream3->CR = 0;

  //Clear all the flags
  DMA2->LIFCR = DMA_LIFCR_CTCIF3 | DMA_LIFCR_CTEIF3 | DMA_LIFCR_CDMEIF3 | DMA_LIFCR_CFEIF3 | DMA_LIFCR_CHTIF3;

  //Set the DMA Addresses
  DMA2_Stream3->PAR=((uint32_t) 0x40012C80);  //SDIO FIFO Address (=SDIO Base+0x80)
  DMA2_Stream3->M0AR=(uint32_t) buf;    //Memory address

  //Set the number of data to transfer
  DMA2_Stream3->NDTR=0;   //Peripheral controls, therefore we don't need to indicate a size

  //Set the DMA CR
  tempreg = 0;
  tempreg |= (0x04<<25) & DMA_SxCR_CHSEL;  //Select Channel 4
  tempreg |= (0x01<<23) & DMA_SxCR_MBURST;  //4 beat memory burst (memory is 32word. Therefore, each time dma access memory, it reads 4*32 bits) (FIFO size must be integer multiple of memory burst)(FIFO is 4byte. Therefore we can only use 4 beat in this case)
  //Note: Ref manual (p173 (the node at the end of 8.3.11) says that burst mode is not allowed when Pinc=0. However, it appears that this is not true at all. Furthermore. when I set pBurst=0, the SDIO's dma control does not work at all.)
  tempreg |= (0x01<<21) & DMA_SxCR_PBURST;  //4 beat memory burst Mode ([Burst Size*Psize] must be equal to [FIFO size] to prevent FIFO underrun and overrun errors) (burst also does not work in direct mode).
  tempreg |= (0x00<<18) & DMA_SxCR_DBM;   //Disable double buffer mode (when this is set, circluar mode is also automatically set. (the actual value is don't care)
  tempreg |= (0x03<<16) & DMA_SxCR_PL;     //Priority is very_high
  tempreg |= (0x00<<15) & DMA_SxCR_PINCOS;  //Peripheral increment offset (if this is 1 and Pinc=1, then Peripheral will be incremented by 4 regardless of Psize)
  tempreg |= (0x02<<13) & DMA_SxCR_MSIZE;  //Memory data size is 32bit (word)
  tempreg |= (0x02<<11) & DMA_SxCR_PSIZE;  //Peripheral data size is 32bit (word)
  tempreg |= (0x01<<10) & DMA_SxCR_MINC;  //Enable Memory Increment
  tempreg |= (0x00<<9) & DMA_SxCR_MINC;  //Disable Peripheral Increment
  tempreg |= (0x00<<8) & DMA_SxCR_CIRC;   //Disable Circular mode
  //tempreg |= (0x00<<6) & DMA_SxCR_DIR;  //Direction 0:P2M, 1:M2P
  tempreg |= (0x01<<5) & DMA_SxCR_PFCTRL; //Peripheral controls the flow control. (The DMA tranfer ends when the data issues end of transfer signal regardless of ndtr value)
  //Bit [4..1] is for interupt mask. I don't use interrupts here
  //Bit 0 is EN. I will set it after I set the FIFO CR. (FIFO CR cannot be modified when EN=1)
  DMA2_Stream3->CR = tempreg;

  //Set the FIFO CR
  tempreg = 0x21; //Reset value
  tempreg |= (0<<7); //FEIE is disabled
  tempreg |= (1<<2); //Fifo is enabled (Direct mode is disabled);
  tempreg |= 3;   //Full fifo (Fifo threshold selection)
  DMA2_Stream3->FCR = tempreg;

  //Set the Direction of transfer
  if (dir == UM2SD) {
    DMA2_Stream3->CR |= (0x01<<6) & DMA_SxCR_DIR;
  } else if (dir == SD2UM) {
    DMA2_Stream3->CR |= (0x00<<6) & DMA_SxCR_DIR;
  }

  //Enable the DMA (When it is enabled, it starts to respond dma requests)
  DMA2_Stream3->CR |= DMA_SxCR_EN;
  //END of PART I

  ////PART II::::Adjust and enable SDIO Peripheral
  //Clear the Data status flags
  SDMMC1->ICR = (SDMMC_STA_DCRCFAIL | SDMMC_STA_DTIMEOUT | SDMMC_STA_TXUNDERR | SDMMC_STA_RXOVERR | SDMMC_STA_DATAEND | SDMMC_STA_DBCKEND); // SDMMC_STA_STBITERR ??

  //First adjust the Dtimer and Data length
  SDMMC1->DTIMER = (uint32_t) DATATIMEOUT;
  SDMMC1->DLEN = cnt;

  //Now adjust DCTRL (and enable it at the same time)
  tempreg = 0;  //Reset value
  tempreg |= (uint32_t) 9 << 4;  //Block size is 512 Compute log2(BlockSize) and shift 4bit
  tempreg |= 1<<3; //Enable the DMA
  tempreg |= 0<<2; //DTMode=Block Transfer (Actualy this is the reset value. Just a remainder)
  tempreg |= (dir & SDMMC_DCTRL_DTDIR);  //Direction. 0=Controller to card, 1=Card to Controller
  tempreg |= 1; //DPSM is enabled
  //Keep the rest at 0 => OTher SDIO functions is disabled(we don't need them)
  SDMMC1->DCTRL = tempreg;
  //End of PART II

  //Warn everyone that there may be a transfer in progress
  SDIOTxRx = 1;
}


void SD_WaitTransmissionEnd(void)
{
  //This function first checks if there is an ogoing tranmission and block till it ends.
  //It then checks the data flags to see if there is an error. In case of an error it blocks
  //Before the start of data transmission the data flags are all cleared. Therefore, calling this fucntion after a real transmission works as expected.

  ////Check if there is an ongoing transmission
  //Check if the DMA is disabled (SDIO disables the DMA after it is done with it)
  while (DMA2_Stream3->CR & DMA_SxCR_EN) {};
  //Wait for the DMA Interrupt flags if there exist a previous SDIO transfer.
  if (SDIOTxRx) {
    if (DMA2->LISR & (DMA_LISR_TCIF3 | DMA_LISR_TEIF3 | DMA_LISR_DMEIF3 | DMA_LISR_FEIF3)) {
      if (!(DMA2->LISR & DMA_LISR_TCIF3)) {//A DMA error has occured. Panic!
        SD_Panic(DMA2->LISR, "SDIO:DMA Error");
      }
    }
  }

  //Wait till SDIO is not active
  while (SDMMC1->STA & (SDMMC_STA_RXACT | SDMMC_STA_TXACT)) {};

  //if there exist a previous transmission, check if the transmission has been completed without error
  if (SDIOTxRx) {
    //I will block here till I get a data response
    while (!(SDMMC1->STA & (SDMMC_STA_DCRCFAIL | SDMMC_STA_DTIMEOUT | SDMMC_STA_DBCKEND))) {}; // | SDIO_IT_STBITERR ??
    if (!(SDMMC1->STA & SDMMC_STA_DBCKEND)) {  //An Error has occured.
      SD_Panic(SDMMC1->STA, "SDIO:Data Transmission Error\n");
    }
  }

  //If we are here, we can be sure that there is no ongoing transmission any more
  SDIOTxRx=0;
}
static void SD_Panic(uint32_t code, uint8_t *message)
{
  uint32_t i=0;

  printf((char *) message);

  //Block the execution with blinky leds
  while (1) {
    i = 216000000/4;
    while(i--){}
    LL_GPIO_TogglePin(LD3_GPIO_Port, LD3_Pin);
    i = 216000000/4;
    while(i--){}
  }
}
#endif
